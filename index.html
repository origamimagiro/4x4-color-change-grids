<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Grid Generation</title>
</head>
<body style="background:darkgray">
    <div>
        <span style="font-family:sans-serif">
            <b>Grid Generation</b>
        </span>
    </div>
    <div>Â© Jason S. Ku 2022</div>
    <hr>
    <div>
        Website for enumerating all 1x1, 2x2, 3x3, and 4x4 rotationally-symmetric 
        color-change patterns, using the following tiling square units:
    </div>
    <ul>
        <li>A: Full white square
           <svg style="width:10;height:10;background:white" viewBox="0 0 1 1"></svg>
        </li>
        <li>B: Full black square
           <svg style="width:10;height:10;background:black" viewBox="0 0 1 1"></svg>
        </li>
        <li>C: NW black, SE white
           <svg style="width:10;height:10;background:white" viewBox="0 0 1 1">
              <polygon fill="black" points="0,0 0,1 1,0"></polygon>
           </svg>
        </li>
        <li>D: NE black, SW white
           <svg style="width:10;height:10;background:white" viewBox="0 0 1 1">
              <polygon fill="black" points="0,0 1,1 1,0"></polygon>
           </svg>
        </li>
        <li>E: SE black, NW white
           <svg style="width:10;height:10;background:white" viewBox="0 0 1 1">
              <polygon fill="black" points="0,0 0,1 1,1"></polygon>
           </svg>
        </li>
        <li>F: SW black, NE white
           <svg style="width:10;height:10;background:white" viewBox="0 0 1 1">
              <polygon fill="black" points="0,1 1,1 1,0"></polygon>
           </svg>
        </li>
    </ul>
    <div>
        <a href="https://www.flickr.com/photos/danielbrown/">Dan Brown</a> 
        is attempting to design every such pattern in origami 
        as efficiently as he can, 
        seamlessly when possible.
    </div>
    <hr>
    <div>
        <b>1x1:</b> There is only one 1x1 rotationally-symmetric color-change 
        pattern with these tiles, i.e., the uniform square up to inversion:
    </div>
    <hr>
    <div id="main1">
        <div>A1: A, B</div>
        <svg style="width:100;height:100;background:white" viewBox="0 0 1 1"></svg>
        <svg style="width:100;height:100;background:black" viewBox="0 0 1 1"></svg>
    </div>
    <hr>
    <div>
        <b>2x2:</b> Because we only want to generate rotationally-symmetric 
        patterns, we only place tiles in the NW cell of the pattern,
        specifically cell 0 in the 2 x 2 grid:
    </div>
    <pre>
        0+
        ++</pre>
    <div>
        We generate all 6 patterns, and check for duplicates up to 
        reflection and color inversion and list each group, one per row. 
        There are 3 such patterns.
    </div>
    <hr>
    <div id="main2"></div>
    <hr>
    <div>
        <b>3x3:</b> Because we only want to generate rotationally-symmetric 
        patterns, we only place tiles in three cells of the pattern,
        specifically 0, 1, 2 in the 3 x 3 grid, where cells 0,1 may be any tile,
        while cell 2 must be either A or B:
    </div>
    <pre>
        01+
        +2+
        +++</pre>
    <div>
        We generate all 6x6x2 = 72 patterns, and check for duplicates up to 
        reflection and color inversion and list each group, one per row. 
        There are 22 such patterns.
    </div>
    <hr>
    <div id="main3"></div>
    <hr>
    <div>    
        <b>4x4:</b> Because we only want to generate rotationally-symmetric 
        patterns, we only place tiles in the NW quadrant of each pattern. 
        For 2x2 specifically in the four positions 
        0, 1, 2, 3 in the 4 x 4 grid:
    </div>
    <pre>
        01++
        23++
        ++++
        ++++</pre>
    <div>
        We generate all 6^4 = 1296, and check for duplicates up to reflection and
        color inversion and list each group, one per row. There are 354 such
        patterns.
    </div>
    <hr>
    <div id="main4"></div>
    <script>
const chars = "ABCDEF";
const inv_map = {"A": "B", "B": "A", "C": "E", "D": "F", "E": "C", "F": "D"};
const ref_map = {"A": "A", "B": "B", "C": "C", "D": "F", "E": "E", "F": "D"};
const rot_map = {"A": "A", "B": "B", "C": "D", "D": "C", "F": "E", "E": "F"};

const SVGNS = "http://www.w3.org/2000/svg";

const append_SVG = (parent, size) => {
    const svg = document.createElementNS(SVGNS, "svg"); 
    svg.style.width  = "100";
    svg.style.height = "100";
    svg.style.margin = "2";
    svg.style.background = "white";
    svg.setAttribute("viewBox", `0 0 ${size} ${size}`);
    parent.appendChild(svg);
    return svg;
};

const append_polygon = (parent, points) => {
    const poly = document.createElementNS(SVGNS, "polygon"); 
    poly.style.fill  = "black";
    poly.setAttribute("points", points.map(v => v.join(",")).join(" "));
    parent.appendChild(poly);
    return poly;
};

const D1 = [["A", "B"]];
const D2 = [["A", "B"], ["C", "E"], ["D", "F"]];
    
window.onload = () => {
    const main2 = document.getElementById("main2");
    let idx = 1;
    let first = 0;
    for (const A of D2) {
        const name = document.createElement("div");
        main2.appendChild(name);
        while (A[0][0] != chars[first]) {
            ++first;
            idx = 1;
        }
        name.innerHTML = `${chars[first]}${idx}: ${A.join(", ")}`;
        const div = document.createElement("div");
        main2.appendChild(div);
        for (const B of A) {
            const svg = append_SVG(div, 2);
            const c = B[0];
            const [p1, p2, p3, p4] = [
                [0, 0], 
                [0, 1], 
                [1, 1], 
                [1, 0]
            ];
            for (let j = 0; j < 4; ++j) {
                const g = document.createElementNS(SVGNS, "g"); 
                svg.appendChild(g);
                switch (c) { 
                    case "A": 
                        break;
                    case "B":
                        append_polygon(g, [p1, p2, p3, p4]);
                        break;
                    case "C":
                        append_polygon(g, [p1, p2, p4]);
                        break;
                    case "D":
                        append_polygon(g, [p1, p3, p4]);
                        break;
                    case "E":
                        append_polygon(g, [p2, p3, p4]);
                        break;
                    case "F":
                        append_polygon(g, [p1, p2, p3]);
                        break;
                }
                g.setAttribute("transform", `rotate(${90*j} 1 1)`);
            }
        }
        ++idx;
    }

    const D3 = new Map();
    for (c1 of chars) {
        for (c2 of chars) {
            for (c3 of "AB") {
                const B = [c1, c2, c3];
                const R = B.map(c => c);
                R[0] = ref_map[R[0]];
                R[1] = rot_map[R[1]];
                const I = B.map(c => inv_map[c]);
                const RI = R.map(c => inv_map[c]);
                let seen = false;
                const Bstr = B.join("");
                for (BB of [R, I, RI]) {
                    const str = BB.join("");
                    if (D3.has(str)) {
                        D3.get(str).push(Bstr);
                        seen = true;
                        break;
                    }
                }
                if (!seen) {
                    D3.set(Bstr, [Bstr]);
                }
            }
        }
    }

    const main3 = document.getElementById("main3");
    idx = 1;
    first = 0;
    for (const [_, A] of D3) {
        const name = document.createElement("div");
        main3.appendChild(name);
        while (A[0][0] != chars[first]) {
            ++first;
            idx = 1;
        }
        name.innerHTML = `${chars[first]}${idx}: ${A.join(", ")}`;
        const div = document.createElement("div");
        main3.appendChild(div);
        for (const B of A) {
            const svg = append_SVG(div, 3);
            if (B[2] == "B") {
                append_polygon(svg, [[1,1], [1,2], [2,2], [2,1]]);
            }
            for (let i = 0; i < 2; ++i) {
                const c = B[i];
                const x = i % 2;
                const [p1, p2, p3, p4] = [
                    [x, 0], 
                    [x, 1], 
                    [x + 1, 1], 
                    [x + 1, 0]
                ];
                for (let j = 0; j < 4; ++j) {
                    const g = document.createElementNS(SVGNS, "g"); 
                    svg.appendChild(g);
                    switch (c) { 
                        case "A": 
                            break;
                        case "B":
                            append_polygon(g, [p1, p2, p3, p4]);
                            break;
                        case "C":
                            append_polygon(g, [p1, p2, p4]);
                            break;
                        case "D":
                            append_polygon(g, [p1, p3, p4]);
                            break;
                        case "E":
                            append_polygon(g, [p2, p3, p4]);
                            break;
                        case "F":
                            append_polygon(g, [p1, p2, p3]);
                            break;
                    }
                    g.setAttribute("transform", `rotate(${90*j} 1.5 1.5)`);
                }
            }
        }
        ++idx;
    }

    const D4 = new Map();
    for (c1 of chars) {
        for (c2 of chars) {
            for (c3 of chars) {
                for (c4 of chars) {
                    const B = [c1, c2, c3, c4];
                    const R = B.map(c => ref_map[c]);
                    [R[1], R[2]] = [R[2], R[1]];
                    const I = B.map(c => inv_map[c]);
                    const RI = R.map(c => inv_map[c]);
                    let seen = false;
                    const Bstr = B.join("");
                    for (BB of [R, I, RI]) {
                        const str = BB.join("");
                        if (D4.has(str)) {
                            D4.get(str).push(Bstr);
                            seen = true;
                            break;
                        }
                    }
                    if (!seen) {
                        D4.set(Bstr, [Bstr]);
                    }
                }
            }
        }
    }

    const main4 = document.getElementById("main4");
    idx = 1;
    first = 0;
    for (const [_, A] of D4) {
        const name = document.createElement("div");
        main4.appendChild(name);
        while (A[0][0] != chars[first]) {
            ++first;
            idx = 1;
        }
        name.innerHTML = `${chars[first]}${idx}: ${A.join(", ")}`;
        const div = document.createElement("div");
        main4.appendChild(div);
        for (const B of A) {
            const svg = append_SVG(div, 4);
            for (let i = 0; i < 4; ++i) {
                const c = B[i];
                const x = i % 2;
                const y = (i < 2) ? 0 : 1;
                const [p1, p2, p3, p4] = [
                    [x, y], 
                    [x, y + 1], 
                    [x + 1, y + 1], 
                    [x + 1, y]
                ];
                for (let j = 0; j < 4; ++j) {
                    const g = document.createElementNS(SVGNS, "g"); 
                    svg.appendChild(g);
                    switch (c) { 
                        case "A": 
                            break;
                        case "B":
                            append_polygon(g, [p1, p2, p3, p4]);
                            break;
                        case "C":
                            append_polygon(g, [p1, p2, p4]);
                            break;
                        case "D":
                            append_polygon(g, [p1, p3, p4]);
                            break;
                        case "E":
                            append_polygon(g, [p2, p3, p4]);
                            break;
                        case "F":
                            append_polygon(g, [p1, p2, p3]);
                            break;
                    }
                    g.setAttribute("transform", `rotate(${90*j} 2 2)`);
                }
            }
        }
        ++idx;
    }
};
    </script>
</body>
</html>
